#! /bin/sh
# Manage git tokens with password encrypted files.
#
# Author: Kaj Munhoz Arfvidsson


###############
## CONSTANTS ##
###############


DATA_DIR="$HOME/.local/share/git-token"


###############
## FUNCTIONS ##
###############


usage() {
    echo 'Usage: git-token [OPTIONS] USERNAME [TOKEN] [NAME EMAIL]'
}

help() {
    usage
    cat << EOF
Manage git tokens with password protected files.

OPTIONS
    -h, --help          Show this help message.
    -e, --enable        Enable git credential-cache in globally.
    -t SEC              Set git credential-cache timeout to SECONDS, only used
        --timeout=SEC     with -e option (default "900").
    -r, --remove        Remove token with name USERNAME.
    -u URL              Set the git domain url, must be used with password
        --url=URL         decryption (default "github.com").
    -f, --force         Write over any existing token.

STATE
    > git config user.name
    --> $(git config user.name)

    > git config user.email
    --> $(git config user.email)

    > git config credential.helper
    --> $(git config credential.helper)

To save a token: git-token adam xxyyzz
The program will encrypt with gnupg a file named "adam"
containing "xxyyzz" to the directory ~/.local/share/git-token.

To load a token: git-token adam
The program will try to decrypt the file
~/.local/share/git-token/adam, print the contents, and call
git credential to save the login credentials for a limited time.
EOF
}

# Return the argument at index
# > index [-]NUM [ARGS...]
index() {
    [ $# -lt 2 ] && return 1
    [ $1 -gt 0 ] && i=$1 || i=$(($# + $1))
    [ $i -le 0 ] && echo "" || ( shift $i && echo "$1" )
}

# Print error and exit
# > panic [CODE] MESSAGE
panic() {
    [ $# -gt 1 ] && CODE=$1 && shift || CODE=1
    echo "Error ($CODE): $1"
    usage
    exit $CODE
}

# Assert there exist commands 
# > assert_command [COMMANDS...]
assert_command() {
    for cmd in "$@"; do
        [ ! "$(command -v "$cmd")" ] && panic "Missing command \"$cmd\". Is it installed?"
    done
}

# Enable git credentials
_enable() {
    git config --global credential.helper "cache --timeout $1" || exit $?
}

# Remove user token
_remove() {
    rm "$DATA_DIR/$1" || exit $?
}

# Approve git credential with _approve URL USERNAME PASSWORD
_approve() {
    git credential approve << EOF
url=$1
username=$2
password=$3
EOF
return $?
}


############
## SCRIPT ##
############


assert_command git gpg

# program arguments
REMOVE=0
ENABLE=0
FORCE=0
TIMEOUT=900
URL="https://github.com"
USERNAME=""
TOKEN=""
NAME=""
EMAIL=""

# parse program arguments
while getopts ":herfd:-:" OPT; do
    if [ "$OPT" = "-" ]; then
        OPT="${OPTARG%%=*}"
        OPTARG="${OPTARG#$OPT}"
        OPTARG="${OPTARG#=}"
    fi
    case $OPT in
        h | help ) help ; exit 0 ;;
        e | enable) ENABLE=1 ;;
        t | timeout) TIMEOUT="$OPTARG" ;;
        r | remove) REMOVE=1 ;;
        u | url)
            URL="$OPTARG"
            [ -z "$URL" ] && panic "Missing argument to \"$OPT\""
            ;;
        f | force) FORCE=1 ;;
        : ) panic "Missing argument to \"$OPTARG\"" ;;
        * ) panic "Unrecognized option \"$OPTARG\"" ;;
    esac
done
shift $((OPTIND-1))

# get program positional arguments
case "$#" in
    0 )
        [ "$ENABLE" -ne 0 ] && _enable "$TIMEOUT" && exit 0
        panic "Missing argument USERNAME"
        ;;
    1 )
        USERNAME=$1
        [ $ENABLE -ne 0 ] && _enable "$TIMEOUT"
        [ $REMOVE -ne 0 ] && _remove "$USERNAME" && exit 0
        ;;
    2 )
        USERNAME=$1
        TOKEN=$2
        [ $ENABLE -ne 0 ] && _enable "$TIMEOUT"
        [ $REMOVE -ne 0 ] && echo "Replacing token for \"$USERNAME\"" && _remove "$USERNAME"
        ;;
    3 )
        panic "If NAME is given, so must EMAIL"
        ;;
    4 )
        USERNAME=$1
        TOKEN=$2
	NAME=$3
	EMAIL=$4
        [ $ENABLE -ne 0 ] && _enable "$TIMEOUT"
        [ $REMOVE -ne 0 ] && echo "Replacing token for \"$USERNAME\"" && _remove "$USERNAME"
        ;;
    * )
        panic "Too many arguments"
        ;;
esac

# get token from stdin if the token is, e.g. piped in
[ -p /dev/stdin ] && read -r TOKEN

# Retrieve password
stty -echo
printf "Password: "
read -r PASSWD
stty echo
printf "\n"

if [ -n "$TOKEN" ]
then # encrypt

    [ ! -d "$DATA_DIR/$USERNAME" ] && mkdir -p "$DATA_DIR/$USERNAME"
    [ $FORCE -eq 0 ] && [ -d "$DATA_DIR/$USERNAME" ] && panic "This user already exists"
    echo "$TOKEN" | gpg --batch --yes --passphrase "$PASSWD" -o "$DATA_DIR/$USERNAME/token" -c || panic $? "Encryption failed"
    [ -n "$NAME" ] && echo "$NAME" > "$DATA_DIR/$USERNAME/name"
    [ -n "$EMAIL" ] && echo "$EMAIL" > "$DATA_DIR/$USERNAME/email"

elif [ -d "$DATA_DIR/$USERNAME" ]
then # decrypt

    SECRET=$(gpg --batch --passphrase "$PASSWD" -d "$DATA_DIR/$USERNAME/token" 2> /dev/null)
    _approve "$URL" "$USERNAME" "$SECRET" || panic $? "Approval failed"

    [ -f "$DATA_DIR/$USERNAME/name" ] && git config --global user.name "$NAME"
    [ -f "$DATA_DIR/$USERNAME/email" ] && git config --global user.email "$NAME"

    if [ "$(index 1 $(git config credential.helper))" = "cache" ]
    then
        echo "Found token \"$SECRET\" and cached it for a limited time."
    else
        echo "Token \"$SECRET\" found."
        echo ""
        echo "WARNING: git credential-cache is disabled, you will have to enter the token"
        echo "manually. Enable git credential-cache globally with"
        echo "> git token -e"
    fi

else panic "Cannot find \"$DATA_DIR/$USERNAME\" containing the requested token."
fi

