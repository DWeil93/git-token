#! /bin/sh
# Manage git tokens with password encrypted files.
#
# Author: Kaj Munhoz Arfvidsson


###############
## CONSTANTS ##
###############


DATA_DIR="$HOME/.local/share/git-token"
GIT_CRED="$HOME/.git-credentials"


###############
## FUNCTIONS ##
###############


usage() {
    echo 'Usage: git-token [-herf] USERNAME [TOKEN]'
}

help() {
    usage
    cat << EOF
Manage git tokens with password protected files.

Options:
    -h, --help          Show this help message
    -r, --remove        Remove token with name USERNAME
    -e, --enable        Enable git credentials in the local repository
    -f, --force         Write over any existing token
    -d DOMAIN           Set the git domain, default is "github.com"
        --domain=DOMAIN

To save a token: git-token adam xxyyzz
The program will encrypt with gnupg a file named "adam"
containing "xxyyzz" to the directory ~/.local/share/git-token.

To load a token: git-token adam
The program will try to decrypt the file
~/.local/share/git-token/adam and print the contents, as well as,
save the token in ~/.git-credentials for a limited time (10m).
EOF
}

# Print error and exit
panic() {
    [ $# -gt 0 ] && echo "Error: $*"
    usage
    exit 1
}

# Enable git credentials
_enable() {
    git config --global credential.store helper
}

# Remove user token
_remove() {
    rm "$DATA_DIR/$1"    
}


############
## SCRIPT ##
############


# program arguments
REMOVE=0
ENABLE=0
FORCE=0
DOMAIN="github.com"
USERNAME=""
TOKEN=""

# parse program arguments
while getopts ":herfd:-:" OPT; do
    if [ "$OPT" = "-" ]; then
        OPT="${OPTARG%%=*}"
        OPTARG="${OPTARG#$OPT}"
        OPTARG="${OPTARG#=}"
    fi
    case $OPT in
        h | help ) help ; exit 0 ;;
        e | enable) ENABLE=1 ;;
        r | remove) REMOVE=1 ;;
	f | force) FORCE=1 ;;
	d | domain) 
	    DOMAIN="$OPTARG" 
	    [ -z "$DOMAIN" ] && panic "Missing argument to \"$OPT\"" 
	    ;;
	: ) panic "Missing argument to \"$OPTARG\"" ;;
        * ) panic "Unrecognized option \"$OPTARG\"" ;;
    esac
done
shift $((OPTIND-1))

# get program positional arguments
case "$#" in
    0 )
        [ "$ENABLE" -ne 0 ] && _enable && exit 0
        panic "Missing argument USERNAME"
        ;;
    1 ) 
        USERNAME=$1
        [ $ENABLE -ne 0 ] && _enable
	[ $REMOVE -ne 0 ] && _remove "$USERNAME" && exit 0
        ;;
    2 ) 
        USERNAME=$1
        TOKEN=$2
        [ $ENABLE -ne 0 ] && _enable
        [ $REMOVE -ne 0 ] && panic "Cannot add and remove token at the same time"
        ;;
    * )
        panic "Too many arguments"
        ;;
esac

# get token from stdin if the token is, e.g. piped in
[ -p /dev/stdin ] && read -r TOKEN

# check deps
[ ! "$(command -v gpg)" ] && panic 'Missing dependency "gnupg"'
[ ! "$(command -v at)" ] && panic 'Missing dependency "at"'

# Retrieve password
stty -echo
printf "Password: "
read -r PASSWD
stty echo
printf "\n"

if [ -n "$TOKEN" ]; then
    # encrypt
    [ ! -d "$DATA_DIR" ] && mkdir -p "$DATA_DIR"
    [ $FORCE -eq 0 ] && [ -f "$DATA_DIR/$USERNAME" ] && panic "This name already exists"
    echo "$TOKEN" | gpg --batch --yes --passphrase "$PASSWD" -o "$DATA_DIR/$USERNAME" -c
elif [ -f "$DATA_DIR/$USERNAME" ]; then
    # decrypt
    SECRET=$(gpg --batch --passphrase "$PASSWD" -d "$DATA_DIR/$USERNAME" 2> /dev/null)
    echo "https://$USERNAME:$SECRET@$DOMAIN" > "$GIT_CRED"
    echo "[ -f '$GIT_CRED' ] && rm '$GIT_CRED'" | at now +10 minutes 2> /dev/null
    echo "Token \"$SECRET\" written to clipboard and saved to git-credentials for 10 min."
else
    panic "File $DATA_DIR/$USERNAME does not exist"
fi


